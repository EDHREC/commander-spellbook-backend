# Generated by Django 4.1 on 2022-09-29 09:05

from django.conf import settings
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import sortedm2m.fields


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Card',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Card name', max_length=255, unique=True, verbose_name='name of card')),
                ('oracle_id', models.UUIDField(blank=True, help_text='Scryfall Oracle ID', null=True, unique=True, verbose_name='Scryfall Oracle ID of card')),
                ('added', models.DateTimeField(auto_now_add=True)),
                ('updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'card',
                'verbose_name_plural': 'cards',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Combo',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('zone_locations', models.TextField(blank=True, default='', help_text='Starting locations for cards.')),
                ('cards_state', models.TextField(blank=True, default='', help_text='State of cards in their starting locations.')),
                ('mana_needed', models.CharField(blank=True, default='', help_text='Mana needed for this combo. Use the {1}{W}{U}{B}{R}{G}{B/P}... format.', max_length=200, validators=[django.core.validators.RegexValidator(message='Mana needed must be in the {1}{W}{U}{B}{R}{G}{B/P}... format.', regex='^(\\{(?:[0-9WUBRGCXS]|[1-9][0-9]|([2WUBRG])(?:\\/(?!\\2)[WUBRG])?(?:\\/P)?)\\} *)*$')])),
                ('other_prerequisites', models.TextField(blank=True, default='', help_text='Other prerequisites for this combo.')),
                ('description', models.TextField(blank=True, help_text='Long description of the combo, in steps')),
                ('generator', models.BooleanField(default=True, help_text='Is this combo a generator for variants?', verbose_name='is generator')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'combo',
                'verbose_name_plural': 'combos',
                'ordering': ['created'],
            },
        ),
        migrations.CreateModel(
            name='Feature',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Short name for a produced effect', max_length=255, unique=True, verbose_name='name of feature')),
                ('description', models.TextField(blank=True, help_text='Long description of a produced effect', verbose_name='description of feature')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('updated', models.DateTimeField(auto_now=True)),
                ('utility', models.BooleanField(default=False, help_text='Is this a utility feature? Utility features are hidden to the end users', verbose_name='is utility')),
            ],
            options={
                'verbose_name': 'feature',
                'verbose_name_plural': 'features',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Variant',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status', models.CharField(choices=[('N', 'New'), ('D', 'Draft'), ('NW', 'Not Working'), ('OK', 'Ok'), ('R', 'Restore')], default='N', help_text='Variant status for editors', max_length=2)),
                ('zone_locations', models.TextField(blank=True, default='', help_text='Starting locations for cards.')),
                ('cards_state', models.TextField(blank=True, default='', help_text='State of cards in their starting locations.')),
                ('mana_needed', models.CharField(blank=True, default='', help_text='Mana needed for this combo. Use the {1}{W}{U}{B}{R}{G}{B/P}... format.', max_length=200, validators=[django.core.validators.RegexValidator(message='Mana needed must be in the {1}{W}{U}{B}{R}{G}{B/P}... format.', regex='^(\\{(?:[0-9WUBRGCXS]|[1-9][0-9]|([2WUBRG])(?:\\/(?!\\2)[WUBRG])?(?:\\/P)?)\\} *)*$')])),
                ('other_prerequisites', models.TextField(blank=True, default='', help_text='Other prerequisites for this variant.')),
                ('description', models.TextField(blank=True, help_text='Long description of the variant, in steps')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('updated', models.DateTimeField(auto_now=True)),
                ('unique_id', models.CharField(editable=False, help_text='Unique ID for this variant', max_length=128, unique=True)),
                ('frozen', models.BooleanField(default=False, help_text='Is this variant undeletable?', verbose_name='is frozen')),
                ('includes', models.ManyToManyField(editable=False, help_text='Combo that this variant includes', related_name='included_in_variants', to='spellbook.combo')),
                ('of', models.ManyToManyField(editable=False, help_text='Combo that this variant is an instance of', related_name='variants', to='spellbook.combo')),
                ('produces', sortedm2m.fields.SortedManyToManyField(editable=False, help_text='Features that this variant produces', related_name='produced_by_variants', to='spellbook.feature')),
                ('uses', sortedm2m.fields.SortedManyToManyField(editable=False, help_text='Cards that this variant uses', related_name='used_in_variants', to='spellbook.card')),
            ],
            options={
                'verbose_name': 'variant',
                'verbose_name_plural': 'variants',
                'ordering': ['-status', '-created'],
            },
        ),
        migrations.CreateModel(
            name='Job',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255, verbose_name='name of job')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('expected_termination', models.DateTimeField()),
                ('termination', models.DateTimeField(blank=True, null=True)),
                ('status', models.CharField(choices=[('S', 'Success'), ('F', 'Failure'), ('P', 'Pending')], default='P', max_length=2)),
                ('message', models.TextField(blank=True)),
                ('started_by', models.ForeignKey(blank=True, help_text='User that started this job', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='started_jobs', to=settings.AUTH_USER_MODEL)),
                ('variants', models.ManyToManyField(blank=True, editable=False, help_text='Variants that this job added or updated', related_name='jobs', to='spellbook.variant', verbose_name='variants updated')),
            ],
            options={
                'verbose_name': 'job',
                'verbose_name_plural': 'jobs',
                'ordering': ['-created', 'name'],
            },
        ),
        migrations.AddField(
            model_name='combo',
            name='needs',
            field=models.ManyToManyField(blank=True, help_text='Features that this combo needs', related_name='needed_by_combos', to='spellbook.feature', verbose_name='needed features'),
        ),
        migrations.AddField(
            model_name='combo',
            name='produces',
            field=models.ManyToManyField(help_text='Features that this combo produces', related_name='produced_by_combos', to='spellbook.feature', verbose_name='produced features'),
        ),
        migrations.AddField(
            model_name='combo',
            name='removes',
            field=models.ManyToManyField(blank=True, help_text='Features that this combo removes', related_name='removed_by_combos', to='spellbook.feature', verbose_name='removed features'),
        ),
        migrations.AddField(
            model_name='combo',
            name='uses',
            field=models.ManyToManyField(blank=True, help_text='Cards that this combo uses', related_name='used_in_combos', to='spellbook.card', verbose_name='used cards'),
        ),
        migrations.AddField(
            model_name='card',
            name='features',
            field=models.ManyToManyField(blank=True, help_text='Features provided by this single card effects or characteristics', related_name='cards', to='spellbook.feature'),
        ),
        migrations.AddIndex(
            model_name='variant',
            index=models.Index(fields=['unique_id'], name='unique_variant_index'),
        ),
        migrations.AddIndex(
            model_name='job',
            index=models.Index(fields=['name'], name='job_name_index'),
        ),
        migrations.AddConstraint(
            model_name='job',
            constraint=models.CheckConstraint(check=models.Q(('expected_termination__gte', models.F('created'))), name='job_expected_termination_gte_created'),
        ),
    ]
