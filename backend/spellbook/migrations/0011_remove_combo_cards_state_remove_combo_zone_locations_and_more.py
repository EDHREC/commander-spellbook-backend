# Generated by Django 4.1.5 on 2023-02-08 14:08

import django.core.validators
from django.db import migrations, models
import django.db.models.deletion


def create_through_relation(apps, schema_editor):
    Combo = apps.get_model('spellbook', 'Combo')
    CardInCombo = apps.get_model('spellbook', 'CardInCombo')
    TemplateInCombo = apps.get_model('spellbook', 'TemplateInCombo')
    for combo in Combo.objects.all():
        for order, card in enumerate(combo.uses.all()):
            CardInCombo(combo=combo, card=card, order=order).save()
        for order, template in enumerate(combo.requires.all()):
            TemplateInCombo(combo=combo, template=template, order=order).save()
    Variant = apps.get_model('spellbook', 'Variant')
    CardInVariant = apps.get_model('spellbook', 'CardInVariant')
    TemplateInVariant = apps.get_model('spellbook', 'TemplateInVariant')
    for variant in Variant.objects.all():
        for order, card in enumerate(variant.uses.all()):
            CardInVariant(variant=variant, card=card, order=order).save()
        for order, template in enumerate(variant.requires.all()):
            TemplateInVariant(variant=variant, template=template, order=order).save()



class Migration(migrations.Migration):

    dependencies = [
        ('spellbook', '0010_card_legal_variant_legal'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='combo',
            name='cards_state',
        ),
        migrations.RemoveField(
            model_name='combo',
            name='zone_locations',
        ),
        migrations.RemoveField(
            model_name='variant',
            name='cards_state',
        ),
        migrations.RemoveField(
            model_name='variant',
            name='zone_locations',
        ),
        migrations.CreateModel(
            name='TemplateInVariant',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('order', models.IntegerField(help_text='Order of the card in the combo.', verbose_name='order')),
                ('zone_location', models.CharField(choices=[('H', 'Hand'), ('B', 'Battlefield'), ('C', 'Command Zone'), ('G', 'Graveyard'), ('L', 'Library'), ('E', 'Exile')], default='H', help_text='Starting location for the card.', max_length=2, verbose_name='starting location')),
                ('card_state', models.CharField(blank=True, default='', help_text='State of the card in its starting location.', max_length=200, validators=[django.core.validators.RegexValidator(message='Unpaired double square brackets are not allowed.', regex='^(?:[^\\[]*(?:\\[(?!\\[)|\\[{2}[^\\[]+\\]{2}|\\[{3,}))*[^\\[]*$'), django.core.validators.RegexValidator(message='Symbols must be in the {1}{W}{U}{B}{R}{G}{B/P}{A}{E}{T}{Q}... format.', regex='^(?:[^\\{]*\\{(?:[0-9WUBRGCPXYZSTQEA½∞]|PW|CHAOS|TK|[1-9][0-9]{1,2}|H[WUBRG]|(?:2\\/[WUBRG]|W\\/U|W\\/B|B\\/R|B\\/G|U\\/B|U\\/R|R\\/G|R\\/W|G\\/W|G\\/U)(?:\\/P)?)\\})*[^\\{]*$')], verbose_name='starting card state')),
                ('template', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.template')),
                ('variant', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.variant')),
            ],
            options={
                'ordering': ['order'],
                'abstract': False,
                'unique_together': {('template', 'variant'), ('order', 'variant')},
            },
        ),
        migrations.CreateModel(
            name='TemplateInCombo',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('order', models.IntegerField(help_text='Order of the card in the combo.', verbose_name='order')),
                ('zone_location', models.CharField(choices=[('H', 'Hand'), ('B', 'Battlefield'), ('C', 'Command Zone'), ('G', 'Graveyard'), ('L', 'Library'), ('E', 'Exile')], default='H', help_text='Starting location for the card.', max_length=2, verbose_name='starting location')),
                ('card_state', models.CharField(blank=True, default='', help_text='State of the card in its starting location.', max_length=200, validators=[django.core.validators.RegexValidator(message='Unpaired double square brackets are not allowed.', regex='^(?:[^\\[]*(?:\\[(?!\\[)|\\[{2}[^\\[]+\\]{2}|\\[{3,}))*[^\\[]*$'), django.core.validators.RegexValidator(message='Symbols must be in the {1}{W}{U}{B}{R}{G}{B/P}{A}{E}{T}{Q}... format.', regex='^(?:[^\\{]*\\{(?:[0-9WUBRGCPXYZSTQEA½∞]|PW|CHAOS|TK|[1-9][0-9]{1,2}|H[WUBRG]|(?:2\\/[WUBRG]|W\\/U|W\\/B|B\\/R|B\\/G|U\\/B|U\\/R|R\\/G|R\\/W|G\\/W|G\\/U)(?:\\/P)?)\\})*[^\\{]*$')], verbose_name='starting card state')),
                ('combo', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.combo')),
                ('template', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.template')),
            ],
            options={
                'ordering': ['order'],
                'abstract': False,
                'unique_together': {('order', 'combo'), ('template', 'combo')},
            },
        ),
        migrations.CreateModel(
            name='CardInVariant',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('order', models.IntegerField(help_text='Order of the card in the combo.', verbose_name='order')),
                ('zone_location', models.CharField(choices=[('H', 'Hand'), ('B', 'Battlefield'), ('C', 'Command Zone'), ('G', 'Graveyard'), ('L', 'Library'), ('E', 'Exile')], default='H', help_text='Starting location for the card.', max_length=2, verbose_name='starting location')),
                ('card_state', models.CharField(blank=True, default='', help_text='State of the card in its starting location.', max_length=200, validators=[django.core.validators.RegexValidator(message='Unpaired double square brackets are not allowed.', regex='^(?:[^\\[]*(?:\\[(?!\\[)|\\[{2}[^\\[]+\\]{2}|\\[{3,}))*[^\\[]*$'), django.core.validators.RegexValidator(message='Symbols must be in the {1}{W}{U}{B}{R}{G}{B/P}{A}{E}{T}{Q}... format.', regex='^(?:[^\\{]*\\{(?:[0-9WUBRGCPXYZSTQEA½∞]|PW|CHAOS|TK|[1-9][0-9]{1,2}|H[WUBRG]|(?:2\\/[WUBRG]|W\\/U|W\\/B|B\\/R|B\\/G|U\\/B|U\\/R|R\\/G|R\\/W|G\\/W|G\\/U)(?:\\/P)?)\\})*[^\\{]*$')], verbose_name='starting card state')),
                ('card', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.card')),
                ('variant', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.variant')),
            ],
            options={
                'ordering': ['order'],
                'abstract': False,
                'unique_together': {('card', 'variant'), ('order', 'variant')},
            },
        ),
        migrations.CreateModel(
            name='CardInCombo',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('order', models.IntegerField(help_text='Order of the card in the combo.', verbose_name='order')),
                ('zone_location', models.CharField(choices=[('H', 'Hand'), ('B', 'Battlefield'), ('C', 'Command Zone'), ('G', 'Graveyard'), ('L', 'Library'), ('E', 'Exile')], default='H', help_text='Starting location for the card.', max_length=2, verbose_name='starting location')),
                ('card_state', models.CharField(blank=True, default='', help_text='State of the card in its starting location.', max_length=200, validators=[django.core.validators.RegexValidator(message='Unpaired double square brackets are not allowed.', regex='^(?:[^\\[]*(?:\\[(?!\\[)|\\[{2}[^\\[]+\\]{2}|\\[{3,}))*[^\\[]*$'), django.core.validators.RegexValidator(message='Symbols must be in the {1}{W}{U}{B}{R}{G}{B/P}{A}{E}{T}{Q}... format.', regex='^(?:[^\\{]*\\{(?:[0-9WUBRGCPXYZSTQEA½∞]|PW|CHAOS|TK|[1-9][0-9]{1,2}|H[WUBRG]|(?:2\\/[WUBRG]|W\\/U|W\\/B|B\\/R|B\\/G|U\\/B|U\\/R|R\\/G|R\\/W|G\\/W|G\\/U)(?:\\/P)?)\\})*[^\\{]*$')], verbose_name='starting card state')),
                ('card', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.card')),
                ('combo', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='spellbook.combo')),
            ],
            options={
                'ordering': ['order'],
                'abstract': False,
                'unique_together': {('order', 'combo'), ('card', 'combo')},
            },
        ),
        migrations.RunPython(create_through_relation, reverse_code=migrations.RunPython.noop),
        migrations.RemoveField(
            model_name='combo',
            name='requires',
        ),
        migrations.RemoveField(
            model_name='combo',
            name='uses',
        ),
        migrations.RemoveField(
            model_name='variant',
            name='requires',
        ),
        migrations.RemoveField(
            model_name='variant',
            name='uses',
        ),
        migrations.AddField(
            model_name='combo',
            name='requires',
            field=models.ManyToManyField(blank=True, help_text='Templates that this combo requires', related_name='required_by_combos', through='spellbook.TemplateInCombo', to='spellbook.template', verbose_name='required templates'),
        ),
        migrations.AddField(
            model_name='combo',
            name='uses',
            field=models.ManyToManyField(blank=True, help_text='Cards that this combo uses', related_name='used_in_combos', through='spellbook.CardInCombo', to='spellbook.card', verbose_name='used cards'),
        ),
        migrations.AddField(
            model_name='variant',
            name='requires',
            field=models.ManyToManyField(blank=True, help_text='Templates that this variant requires', related_name='required_by_variants', through='spellbook.TemplateInVariant', to='spellbook.template', verbose_name='required templates'),
        ),
        migrations.AddField(
            model_name='variant',
            name='uses',
            field=models.ManyToManyField(editable=False, help_text='Cards that this variant uses', related_name='used_in_variants', through='spellbook.CardInVariant', to='spellbook.card'),
        ),
    ]
